<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AIS Map (Digitraffic + Leaflet)</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #050812; }

    #map {
      height: 100%;
      width: 100%;
      position: relative;
      background: #020818;
    }

    /* Pseudo-3D fiilis: kevyt “horizon”-overlay kartan yläosassa */
    .sky-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 35%;
      pointer-events: none;
      z-index: 500;
      background: linear-gradient(
        to bottom,
        rgba(5, 8, 18, 0.9),
        rgba(5, 8, 18, 0.0)
      );
      mix-blend-mode: multiply;
    }

    .vessel-svg-icon {
      background: none !important;
      border: none !important;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.6));
    }

    .attribution {
      position: fixed;
      bottom: 4px; left: 4px;
      background: rgba(255,255,255,0.9);
      padding: 3px 8px;
      font-size: 11px;
      color: #222;
      border-radius: 4px;
      z-index: 9999;
      pointer-events: none;
    }

    /* Kartan kontrollit vähän tummemmaksi “navi”-fiilikseen */
    .leaflet-control {
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
    }
    .leaflet-control-zoom a {
      background: rgba(30,30,40,0.9);
      color: #f5f5f5;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .leaflet-bar a:hover {
      background: rgba(60,60,80,0.95);
      color: #fff;
    }
  </style>
</head>
<body>
<div id="map"></div>
<div class="sky-overlay"></div>

<div class="attribution">
  Data © Fintraffic / Digitraffic (<a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY 4.0</a>).
  Map © OpenStreetMap contributors.
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script>
  const DIGITRAFFIC_USER = "JuhaMatti/AISLeafletDemo";
  const UNLOCODE_URL = "https://raw.githubusercontent.com/datasets/un-locode/master/data/code-list.csv";

  // --- MMSI country CSV ---

  let mmsiCountry = {};

  function loadMmsiCountry(callback) {
    fetch("mmsi_countries.csv")
      .then(res => {
        if (!res.ok) throw new Error("HTTP " + res.status);
        return res.text();
      })
      .then(csv => {
        mmsiCountry = {};
        csv.split(/\r?\n/).forEach(line => {
          line = line.trim();
          if (!line || line.startsWith("Digit")) return;
          const parts = line.split(";");
          if (parts.length < 2) return;
          const digit = parts[0].trim();
          const country = parts[1].trim();
          if (digit && country) mmsiCountry[digit] = country;
        });
        console.log("MMSI countries loaded:", Object.keys(mmsiCountry).length);
        if (callback) callback();
      })
      .catch(err => {
        console.error("Failed to load MMSI country data:", err);
        if (callback) callback();
      });
  }

  function getMmsiCountry(mmsi) {
    if (!mmsi) return "";
    const prefix = String(mmsi).substring(0, 3);
    return mmsiCountry[prefix] || "";
  }

  // --- UN/LOCODE CSV ---

  let unlocodeMap = {};

  function splitCsvLine(line) {
    const result = [];
    let current = "";
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQuotes && line[i + 1] === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (ch === "," && !inQuotes) {
        result.push(current);
        current = "";
      } else {
        current += ch;
      }
    }
    result.push(current);
    return result;
  }

  function loadUnlocode(callback) {
    fetch(UNLOCODE_URL)
      .then(res => {
        if (!res.ok) throw new Error("HTTP " + res.status);
        return res.text();
      })
      .then(csv => {
        unlocodeMap = {};
        const lines = csv.split(/\r?\n/);
        if (!lines.length) return;
        const header = splitCsvLine(lines[0]);
        const idxCountry = header.indexOf("Country");
        const idxLocation = header.indexOf("Location");
        const idxName = header.indexOf("Name");
        if (idxCountry === -1 || idxLocation === -1 || idxName === -1) {
          console.warn("UN/LOCODE header unexpected:", header);
          return;
        }
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          const cols = splitCsvLine(line);
          const country = cols[idxCountry];
          const loc = cols[idxLocation];
          const name = cols[idxName];
          if (!country || !loc || !name) continue;
          const code = (country + loc).replace(/\s+/g, "").toUpperCase();
          unlocodeMap[code] = { name: name, country: country };
        }
        console.log("UNLOCODE entries loaded:", Object.keys(unlocodeMap).length);
        if (callback) callback();
      })
      .catch(err => {
        console.error("Failed to load UN/LOCODE data:", err);
        if (callback) callback();
      });
  }

  function normalizeDestinationCode(raw) {
    if (!raw) return null;
    return String(raw).replace(/\s+/g, "").toUpperCase();
  }

  function decodeDestination(raw) {
    const norm = normalizeDestinationCode(raw);
    if (!norm) return null;
    const entry = unlocodeMap[norm];
    if (!entry) return null;
    return `${entry.name}, ${entry.country}`;
  }

  // --- Utility functions ---

  function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  function formatKnots(value) {
    if (typeof value !== "number" || !isFinite(value)) return "–";
    return value.toFixed(1) + " kn";
  }
  function formatMeters(value) {
    if (typeof value !== "number" || !isFinite(value)) return "–";
    return value.toFixed(1) + " m";
  }
  function formatTimestampMs(tsMs) {
    if (typeof tsMs !== "number" || !isFinite(tsMs)) return "–";
    return new Date(tsMs).toLocaleString();
  }
  function formatLatLon(lat, lon) {
    if (typeof lat !== "number" || typeof lon !== "number") return "–";
    return lat.toFixed(5) + ", " + lon.toFixed(5);
  }
  function safe(value, fallback = "–") {
    return (value === null || value === undefined || value === "") ? fallback : value;
  }

  // --- Ship type, color and name ---

  function shipTypeColor(shipType) {
    if (shipType === undefined || shipType === null) return "#888";
    if (shipType >= 60 && shipType < 70) return "#3a9eea";    // passenger
    if (shipType >= 70 && shipType < 80) return "#f3c300";    // cargo
    if (shipType >= 30 && shipType < 40) return "#e84e1b";    // fishing
    if (shipType >= 80 && shipType < 90) return "#2ecc71";    // tanker
    if (shipType >= 90) return "#ad00ff";                     // special
    if (shipType >= 20 && shipType < 30) return "#aaaaaa";    // tug etc
    if (shipType >= 50 && shipType < 60) return "#1abc9c";    // pilot/SAR
    return "#888";
  }

  function shipTypeName(shipType) {
    if (shipType === undefined || shipType === null) return "Unknown";
    if (shipType >= 20 && shipType < 30) return "Wing-in-ground/Tug/Pusher";
    if (shipType >= 30 && shipType < 40) return "Fishing";
    if (shipType >= 40 && shipType < 50) return "High-speed craft";
    if (shipType >= 50 && shipType < 60) return "Pilot/SAR";
    if (shipType >= 60 && shipType < 70) return "Passenger";
    if (shipType >= 70 && shipType < 80) return "Cargo";
    if (shipType >= 80 && shipType < 90) return "Tanker";
    if (shipType >= 90) return "Other special";
    return "Other/Unknown";
  }

  // Pseudo-3D laivaikoni (yläviisto runko, komentosilta, varjo/aallokko)
  function vesselSvg(speed, angle, color) {
    const rounded = (typeof speed === "number" && isFinite(speed) && speed > 0)
      ? Math.round(speed)
      : "";
    const rot = (typeof angle === "number" && isFinite(angle)) ? angle : 0;
    const hullDark = "#222222";

    return `
      <svg width="48" height="48" viewBox="0 0 48 48"
           xmlns="http://www.w3.org/2000/svg"
           style="transform:rotate(${rot}deg)">

        <!-- “aallokko” perässä -->
        <path d="M10 38 C16 40 20 41 24 41 C28 41 32 40 38 38"
              fill="none"
              stroke="rgba(80,150,255,0.45)"
              stroke-width="2"
              stroke-linecap="round" />

        <!-- laivan runko: terävä keula, leveä perä -->
        <polygon
          points="24,4 34,16 34,34 14,34 14,16"
          fill="${color}"
          stroke="${hullDark}"
          stroke-width="2"
          stroke-linejoin="round"
        />

        <!-- rungon alareunan varjo / vesilinja -->
        <path d="M15 30 L33 30"
              stroke="${hullDark}"
              stroke-width="2"
              stroke-linecap="round"
              opacity="0.7" />

        <!-- komentosilta -->
        <rect x="18" y="17" width="12" height="7"
              fill="#f5f5f5"
              stroke="${hullDark}"
              stroke-width="1" />

        <!-- komentosillan ikkunat -->
        <rect x="19" y="18.5" width="10" height="2.5"
              fill="#4a90e2"
              opacity="0.9" />

        <!-- nopeus keskellä runkoa -->
        <text x="24" y="27"
              font-family="Arial"
              font-size="12"
              font-weight="bold"
              fill="white"
              text-anchor="middle"
              dominant-baseline="middle">
          ${rounded}
        </text>
      </svg>
    `;
  }

  // --- MAP AND DATA LOADING ---

  const leafletMap = L.map("map").setView([60.2, 22.0], 6);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
  }).addTo(leafletMap);

  let vesselLayer = null;
  let firstLoad = true;
  let loading = false;
  const vesselState = {};
  const vesselMetadataByMmsi = {};
  let metadataLoaded = false;

  // “follow vessel” -moodi (kameran lukitus alukseen)
  let followMmsi = null;

  async function fetchVesselMetadata() {
    if (metadataLoaded) return;
    const url = "https://meri.digitraffic.fi/api/ais/v1/vessels";
    const res = await fetch(url, {
      headers: {
        "Digitraffic-User": DIGITRAFFIC_USER,
        "Accept": "application/json"
      }
    });
    if (!res.ok) {
      console.warn("Vessel metadata fetch failed:", res.status, res.statusText);
      return;
    }
    const list = await res.json();
    for (const v of list) {
      if (!v || !v.mmsi) continue;
      vesselMetadataByMmsi[v.mmsi] = v;
    }
    metadataLoaded = true;
    console.log("Vessel metadata count:", list.length);
  }

  async function loadAis() {
    if (loading) return;
    loading = true;
    try {
      if (!metadataLoaded) await fetchVesselMetadata();

      const thirtyMinutesMs = 30 * 60 * 1000;
      const from = Date.now() - thirtyMinutesMs;
      const url = "https://meri.digitraffic.fi/api/ais/v1/locations?from=" + from;
      const res = await fetch(url, {
        headers: {
          "Digitraffic-User": DIGITRAFFIC_USER,
          "Accept": "application/json"
        }
      });
      if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
      const data = await res.json();

      // Update calculated speed for each vessel
      data.features.forEach(feature => {
        const props = feature.properties || {};
        const mmsi = props.mmsi || feature.mmsi;
        if (!mmsi) return;
        const lat = feature.geometry.coordinates[1];
        const lon = feature.geometry.coordinates[0];
        const sog = (typeof props.sog === "number" ? props.sog : undefined);
        let calcSpeedKnots = null;
        const tsExt = props.timestampExternal;
        if (typeof tsExt === "number") {
          const prev = vesselState[mmsi];
          if (prev) {
            const dtMs = tsExt - prev.lastTimestampMs;
            const dtS = dtMs / 1000;
            if (dtS > 5 && dtS < 3600) {
              const distM = haversine(prev.lastLat, prev.lastLon, lat, lon);
              if (distM > 1) {
                calcSpeedKnots = distM * 3600 / (1852 * dtS);
              }
            }
          }
          vesselState[mmsi] = {
            lastLat: lat,
            lastLon: lon,
            lastTimestampMs: tsExt,
            lastCalcSpeedKnots: calcSpeedKnots
          };
        }
      });

      if (vesselLayer) vesselLayer.remove();

      vesselLayer = L.geoJSON(data, {
        pointToLayer: (feature, latlng) => {
          const props = feature.properties || {};
          const mmsi = props.mmsi || feature.mmsi;
          const meta = vesselMetadataByMmsi[mmsi] || {};
          const sog = (typeof props.sog === "number" ? props.sog : undefined);
          let calcSpeedKnots = (vesselState[mmsi] && typeof vesselState[mmsi].lastCalcSpeedKnots === "number")
            ? vesselState[mmsi].lastCalcSpeedKnots
            : null;

          const speed = (typeof calcSpeedKnots === "number" && isFinite(calcSpeedKnots))
            ? calcSpeedKnots
            : (typeof sog === "number" && isFinite(sog) ? sog : 0);

          let angle = (typeof props.heading === "number" && isFinite(props.heading))
            ? props.heading
            : (typeof props.cog === "number" && isFinite(props.cog) ? props.cog : 0);

          const shipType = meta.shipType;
          const color = shipTypeColor(shipType);
          const svgIcon = vesselSvg(speed, angle, color);
          const vesselIcon = L.divIcon({
            className: "vessel-svg-icon",
            html: svgIcon,
            iconSize: [48, 48],
            iconAnchor: [24, 24],
            popupAnchor: [0, -22]
          });

          const name = meta.name || props.name || "Unknown vessel";

          let popupHtml = "";
          popupHtml += `<strong>${safe(name)}</strong><br>`;
          popupHtml += `<strong>MMSI:</strong> ${safe(mmsi)}<br>`;
          popupHtml += `<strong>Flag state:</strong> ${getMmsiCountry(mmsi) || "–"}<br>`;
          if (meta.imo) popupHtml += `<strong>IMO:</strong> ${meta.imo}<br>`;
          if (meta.callSign) popupHtml += `<strong>Callsign:</strong> ${meta.callSign}<br>`;

          if (meta.destination) {
            const decoded = decodeDestination(meta.destination);
            if (decoded) {
              popupHtml += `<strong>Destination:</strong> ${meta.destination} (${decoded})<br>`;
            } else {
              popupHtml += `<strong>Destination:</strong> ${meta.destination}<br>`;
            }
          }

          if (typeof meta.draught === "number") {
            popupHtml += `<strong>Draft:</strong> ${formatMeters(meta.draught / 10)}<br>`;
          }
          if (shipType !== undefined) {
            popupHtml += `<strong>Ship type:</strong> ${shipTypeName(shipType)} (${shipType})<br>`;
          }

          popupHtml += `<hr style="margin:4px 0;">`;
          popupHtml += `<strong>Reported SOG:</strong> ${formatKnots(sog)}<br>`;
          popupHtml += `<strong>Calculated speed:</strong> ${formatKnots(calcSpeedKnots)}<br>`;
          if (props.cog !== undefined) popupHtml += `<strong>COG:</strong> ${props.cog}&deg;<br>`;
          if (props.heading !== undefined) popupHtml += `<strong>Heading:</strong> ${props.heading}&deg;<br>`;
          if (props.navStat !== undefined) popupHtml += `<strong>Nav status code:</strong> ${props.navStat}<br>`;
          if (props.posAcc !== undefined) popupHtml += `<strong>Position accuracy:</strong> ${props.posAcc ? "high" : "low"}<br>`;
          if (props.raim !== undefined) popupHtml += `<strong>RAIM:</strong> ${props.raim ? "on" : "off"}<br>`;
          if (props.rot !== undefined) popupHtml += `<strong>ROT:</strong> ${props.rot}<br>`;
          if (typeof props.timestampExternal === "number") {
            popupHtml += `<strong>Last update:</strong> ${formatTimestampMs(props.timestampExternal)}<br>`;
          } else if (props.timestamp !== undefined) {
            popupHtml += `<strong>Timestamp (AIS UTC sec):</strong> ${props.timestamp}<br>`;
          }
          popupHtml += `<strong>Position:</strong> ${formatLatLon(latlng.lat, latlng.lng)}<br>`;

          const marker = L.marker(latlng, { icon: vesselIcon }).bindPopup(popupHtml);

          // Klikkaamalla laivaa -> kamera seuraa sitä
          marker.on('click', () => {
            followMmsi = mmsi;
          });

          return marker;
        }
      }).addTo(leafletMap);

      // Ensimmäisellä kerralla zoomaa kaikkiin aluksiin
      if (firstLoad) {
        const bounds = vesselLayer.getBounds();
        if (bounds.isValid()) leafletMap.fitBounds(bounds.pad(0.1));
        firstLoad = false;
      }

      // Jos follow-moodi päällä, keskitä kartta valittuun alukseen
      if (followMmsi && vesselState[followMmsi
        const v = vesselState[followMmsi];
        leafletMap.setView([v.lastLat, v.lastLon], leafletMap.getZoom());
      }

      console.log("AIS features:", data.features ? data.features.length : 0);
    } catch (err) {
      console.error("AIS data fetch failed:", err);
    } finally {
      loading = false;
    }
  }

  // --- Load MMSI countries, then UN/LOCODE, then start AIS polling ---

  loadMmsiCountry(() => {
    loadUnlocode(() => {
      loadAis();
      setInterval(loadAis, 60 * 1000);
    });
  });
</script>
</body>
</html>
